## 二叉树
作为红黑树、B-树，B+树等各种常用数据结构的基础，二叉树的重要性不言而喻。
### 二叉树的遍历
树的常用遍历方式有深度优先（DFS）和广度优先遍历（BFS），其中DFS可以细分为前序，中序以及后序遍历。正确理解了前序、中序以及后序的含义之后，大多数工程师都能以递归的方式正确实现这三种遍历。但是，如果要以非递归的方式实现，还需要灵活运用栈。
#### 前序遍历
前序遍历的访问顺序是：先访问当前节点，然后左子节点，最后右子节点。理解了这一点，大多数人很快能写出下面递归的实现。

```java
public void preorder(TreeNode root) {
	handle(root);
	preorder(root.left);
	preorder(root.right);
}
```

> 递归的本质：随着递归调用，对函数进行入栈和出栈 

前序遍历的非递归实现，在理解了递归的本质后，很容易想到使用栈来代替递归的过程。

- 在迭代中，先访问当前节点。
- 然后访问左子节点，但是右子节点还没访问，需要先把左子节点压入栈。
- 出栈时机：在左子节点为空时出栈，这时候前序遍历的下一个节点是其**最低**祖先的右节点，所以这时应该回溯到上一个节点，也就是栈顶节点。
- 这时候需要注意的是：栈里的节点，左子节点都被访问过了。所以出栈之后应该访问其右子节点。如果栈顶节点的右子节点为空，那么继续向上回溯，也就是出栈，直到找到存在的右子节点。
- 对于出栈节点的右子节点，其左右子节点都是没访问过的状态，需要对它重复从第1步开始的处理。

#### 中序遍历
中序遍历的访问顺序为：先访问左子节点，然后访问当前节点，最后右子节点。同样很容易给出下面的递归实现。

```java
public void inorder(TreeNode root) {
	inorder(root.left);
	handle(root);
	inorder(root.right);
}
```

非递归实现同样是用栈实现递归。并且栈里节点和存储顺序也和非递归的前序遍历一样。区别只是访问顺序：迭代过程中遇到左子节点，需要先入栈，直到没有左子节点为空。才弹出栈里节点进行访问。

#### 后序遍历
后序遍历的顺序为：先访问左子节点，然后访问右子节点，最后当前节点。递归遍历实现如下。

```java
public void postorder(TreeNode root) {
	postorder(root.left);
	postorder(root.right);
	handle(root);
}
```

非递归实现，在遇到左子节点的时候先入栈，但是在向左遍历到最”深“层后，需要继续右遍历到最深层。因此，当前节点右子节点存在时，分两种情况处理：

- 一、右子节点没被访问过，直接入栈，等待出栈时，对其自身以及左右子节点进行处理。
- 二、右子节点已经被访问过了，说明这时左右子节点都被访问过了，正在向上回溯。

因此，需要记录右子节点是否被访问过。我们可以在访问完右子节点回溯的过程中，用一个变量prev记录上一轮的当前节点，如果上一轮访问的节点就是当前的右子节点，说明右子节点已经在上一轮处理过了，不需要再入栈，继续回溯即可。代码实现如下：

```java
public List<Integer> postorder(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    LinkedList<TreeNode> stack = new LinkedList<>();
    TreeNode prev = null;
    while (root != null || !stack.isEmpty()) {
        while (root != null) {
            stack.push(root);
            root = root.left;
        }
        root = stack.pop();
        // 两种情况需要处理当前节点并向上回溯：1、右子节点为空，即在向右深度递归的时候到了叶子节点；
        // 2、右子节点不为空，但在上一轮迭代处理过了
        if (root.right == null || prev == root.right) {
            result.add(root.val);
            prev = root;
            // 置为null是为了在下一轮迭代跳过内部的while循环，从栈里弹出父节点
            root = null;
        } else {
            // 如右节点存在，并且还没被处理过，则继续对右节点深度递归
            stack.push(root);
            // 方便下轮迭代对右子节点进行左-右-中的顺序遍历
            root = root.right;
        }
    }
    return result;
}
    
```
